# Basic ESPHome Configuration for Bestway Lay-Z-SPA
# ESP32 VERSION
# Based on the WiFi-remote-for-Bestway-Lay-Z-SPA project
# This configuration supports both 6-wire and 4-wire pump models

substitutions:
  device_name: layzspa-esp32
  friendly_name: "Lay-Z-SPA ESP32"

  # ============================================================
  # PIN CONFIGURATION for ESP32 (6-WIRE 2021 MODEL)
  # ============================================================
  # ESP32 has different GPIO numbers than ESP8266!
  #
  # WIRING from SPA PUMP to ESP32 (via level shifter):
  #
  # Spa Pin -> Level Shifter -> ESP32 Pin
  # ------------------------------------------------
  # Pin 1 (5V)      -> HV        -> 5V/VIN
  # Pin 2 (GND)     -> GND       -> GND
  # Pin 3 (CIO Data) -> HV1<->LV1 -> GPIO21 <- cio_data_pin
  # Pin 4 (CIO Clk)  -> HV2<->LV2 -> GPIO22 <- cio_clk_pin
  # Pin 5 (CIO CS)   -> HV3<->LV3 -> GPIO23 <- cio_cs_pin
  # Pin 6 (DSP Data) -> HV4<->LV4 -> GPIO19 <- dsp_data_pin
  # Pin 7 (DSP Clk)  -> HV5<->LV5 -> GPIO18 <- dsp_clk_pin
  # Pin 8 (DSP CS)   -> HV6<->LV6 -> GPIO5  <- dsp_cs_pin
  #
  # NOTE: These pins avoid strapping pins and boot-critical pins
  # ============================================================

  # ESP32 Pin Configuration (6-wire model)
  cio_data_pin: GPIO21  # CIO Data (6-wire only)
  cio_clk_pin: GPIO22   # CIO Clock (6-wire only)
  cio_cs_pin: GPIO23    # CIO Chip Select (6-wire only)
  dsp_data_pin: GPIO19  # DSP Data (all models)
  dsp_clk_pin: GPIO18   # DSP Clock (all models)
  dsp_cs_pin: GPIO5     # DSP Chip Select (all models)
  audio_pin: GPIO4      # Audio/Buzzer (optional)

  # ============================================================
  # ALTERNATIVE PINS (if you have conflicts)
  # ============================================================
  # These are other safe pins you can use on ESP32:
  # GPIO16, GPIO17, GPIO25, GPIO26, GPIO27, GPIO32, GPIO33
  #
  # AVOID these pins on ESP32:
  # - GPIO0 (boot button)
  # - GPIO2 (on-board LED, strapping pin)
  # - GPIO12 (strapping pin - boot fails if HIGH)
  # - GPIO15 (strapping pin)
  # - GPIO6-11 (connected to flash - DO NOT USE)
  # ============================================================

  # For 4-wire models, only DSP pins are used
  # Adjust the pinout based on your specific model

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}

  platformio_options:
    board_build.flash_mode: dio

  on_boot:
    priority: -100
    then:
      - script.execute: initialize_spa

esp32:
  board: esp32dev  # Use esp32dev for generic ESP32 boards, or nodemcu-32s, etc.
  framework:
    type: arduino

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot in case wifi connection fails
  ap:
    ssid: "${friendly_name} Hotspot"
    password: "layzspa123"

captive_portal:

# Enable logging
logger:
  level: DEBUG
  baud_rate: 115200

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

# Web server for local control
web_server:
  port: 80
  auth:
    username: admin
    password: !secret web_password

# Global variables to store state
globals:
  - id: target_temperature
    type: int
    restore_value: yes
    initial_value: '38'

  - id: current_temperature
    type: float
    restore_value: no
    initial_value: '0'

  - id: heater_state
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: filter_state
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: bubble_state
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: jets_state
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: display_locked
    type: bool
    restore_value: yes
    initial_value: 'false'

  - id: celsius_mode
    type: bool
    restore_value: yes
    initial_value: 'true'

# Custom SPI-like communication component
custom_component:
  - id: spa_controller
    lambda: |-
      class SpaController : public Component {
       public:
        GPIOPin *cio_data_pin;
        GPIOPin *cio_clk_pin;
        GPIOPin *cio_cs_pin;
        GPIOPin *dsp_data_pin;
        GPIOPin *dsp_clk_pin;
        GPIOPin *dsp_cs_pin;

        void setup() override {
          cio_data_pin = new GPIOPin(${cio_data_pin}, OUTPUT);
          cio_clk_pin = new GPIOPin(${cio_clk_pin}, OUTPUT);
          cio_cs_pin = new GPIOPin(${cio_cs_pin}, OUTPUT);
          dsp_data_pin = new GPIOPin(${dsp_data_pin}, INPUT);
          dsp_clk_pin = new GPIOPin(${dsp_clk_pin}, INPUT);
          dsp_cs_pin = new GPIOPin(${dsp_cs_pin}, INPUT);

          cio_cs_pin->digital_write(true);
          cio_clk_pin->digital_write(false);
        }

        void loop() override {
          // Read from DSP
          read_dsp_data();
          // Write to CIO
          write_cio_data();
        }

        void read_dsp_data() {
          // Implement DSP reading logic
          // This would involve bit-banging the SPI-like protocol
        }

        void write_cio_data() {
          // Implement CIO writing logic
          // This would involve bit-banging the SPI-like protocol
        }
      };

      auto spa = new SpaController();
      return {spa};

# Scripts for spa control
script:
  - id: initialize_spa
    then:
      - logger.log: "Initializing Lay-Z-SPA controller (ESP32)..."
      - delay: 2s
      - logger.log: "Spa controller ready"

  - id: send_command
    parameters:
      cmd: int
    then:
      - logger.log:
          format: "Sending command: %d"
          args: ['cmd']

# Sensors
sensor:
  # Current water temperature
  - platform: template
    name: "${friendly_name} Current Temperature"
    id: water_temperature
    device_class: temperature
    state_class: measurement
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    lambda: |-
      return id(current_temperature);
    update_interval: 10s

  # Target temperature
  - platform: template
    name: "${friendly_name} Target Temperature"
    id: target_temp_sensor
    device_class: temperature
    unit_of_measurement: "°C"
    accuracy_decimals: 0
    lambda: |-
      return id(target_temperature);
    update_interval: 10s

  # WiFi Signal
  - platform: wifi_signal
    name: "${friendly_name} WiFi Signal"
    update_interval: 60s

  # Uptime
  - platform: uptime
    name: "${friendly_name} Uptime"
    update_interval: 60s

  # ESP32 internal temperature (bonus feature!)
  - platform: internal_temperature
    name: "${friendly_name} ESP32 Temperature"
    update_interval: 60s

# Binary sensors for status
binary_sensor:
  # Heater status
  - platform: template
    name: "${friendly_name} Heater"
    id: heater_status
    device_class: heat
    lambda: |-
      return id(heater_state);

  # Filter status
  - platform: template
    name: "${friendly_name} Filter"
    id: filter_status
    lambda: |-
      return id(filter_state);

  # Bubbles status
  - platform: template
    name: "${friendly_name} Bubbles"
    id: bubbles_status
    lambda: |-
      return id(bubble_state);

  # Jets status (for models with jets)
  - platform: template
    name: "${friendly_name} Jets"
    id: jets_status
    lambda: |-
      return id(jets_state);

  # Display lock status
  - platform: template
    name: "${friendly_name} Display Locked"
    id: lock_status
    lambda: |-
      return id(display_locked);

# Switches for control
switch:
  # Heater control
  - platform: template
    name: "${friendly_name} Heater Control"
    id: heater_switch
    icon: mdi:fire
    lambda: |-
      return id(heater_state);
    turn_on_action:
      - globals.set:
          id: heater_state
          value: 'true'
      - script.execute:
          id: send_command
          cmd: 1  # Command code for heater on
    turn_off_action:
      - globals.set:
          id: heater_state
          value: 'false'
      - script.execute:
          id: send_command
          cmd: 2  # Command code for heater off

  # Filter control
  - platform: template
    name: "${friendly_name} Filter Control"
    id: filter_switch
    icon: mdi:air-filter
    lambda: |-
      return id(filter_state);
    turn_on_action:
      - globals.set:
          id: filter_state
          value: 'true'
      - script.execute:
          id: send_command
          cmd: 3  # Command code for filter on
    turn_off_action:
      - globals.set:
          id: filter_state
          value: 'false'
      - script.execute:
          id: send_command
          cmd: 4  # Command code for filter off

  # Bubbles control
  - platform: template
    name: "${friendly_name} Bubbles Control"
    id: bubbles_switch
    icon: mdi:chart-bubble
    lambda: |-
      return id(bubble_state);
    turn_on_action:
      - globals.set:
          id: bubble_state
          value: 'true'
      - script.execute:
          id: send_command
          cmd: 5  # Command code for bubbles on
    turn_off_action:
      - globals.set:
          id: bubble_state
          value: 'false'
      - script.execute:
          id: send_command
          cmd: 6  # Command code for bubbles off

  # Jets control (if available)
  - platform: template
    name: "${friendly_name} Jets Control"
    id: jets_switch
    icon: mdi:water
    lambda: |-
      return id(jets_state);
    turn_on_action:
      - globals.set:
          id: jets_state
          value: 'true'
      - script.execute:
          id: send_command
          cmd: 7  # Command code for jets on
    turn_off_action:
      - globals.set:
          id: jets_state
          value: 'false'
      - script.execute:
          id: send_command
          cmd: 8  # Command code for jets off

  # Display lock
  - platform: template
    name: "${friendly_name} Lock Display"
    id: lock_switch
    icon: mdi:lock
    lambda: |-
      return id(display_locked);
    turn_on_action:
      - globals.set:
          id: display_locked
          value: 'true'
      - script.execute:
          id: send_command
          cmd: 9  # Command code for lock
    turn_off_action:
      - globals.set:
          id: display_locked
          value: 'false'
      - script.execute:
          id: send_command
          cmd: 10  # Command code for unlock

  # Temperature unit toggle
  - platform: template
    name: "${friendly_name} Celsius Mode"
    id: celsius_switch
    icon: mdi:temperature-celsius
    lambda: |-
      return id(celsius_mode);
    turn_on_action:
      - globals.set:
          id: celsius_mode
          value: 'true'
    turn_off_action:
      - globals.set:
          id: celsius_mode
          value: 'false'

# Climate control for temperature management
climate:
  - platform: thermostat
    name: "${friendly_name} Thermostat"
    id: spa_climate
    sensor: water_temperature
    min_heating_off_time: 300s
    min_heating_run_time: 300s
    min_idle_time: 30s
    visual:
      min_temperature: 20
      max_temperature: 40
      temperature_step: 1
    heat_action:
      - switch.turn_on: heater_switch
    idle_action:
      - switch.turn_off: heater_switch
    default_preset: Home
    preset:
      - name: Home
        default_target_temperature_low: 38°C
      - name: Eco
        default_target_temperature_low: 35°C

# Number input for target temperature
number:
  - platform: template
    name: "${friendly_name} Set Temperature"
    id: set_temperature
    min_value: 20
    max_value: 40
    step: 1
    unit_of_measurement: "°C"
    icon: mdi:thermometer
    lambda: |-
      return id(target_temperature);
    set_action:
      - globals.set:
          id: target_temperature
          value: !lambda 'return x;'
      - script.execute:
          id: send_command
          cmd: 11  # Command code for temperature change

# Text sensors for status information
text_sensor:
  - platform: template
    name: "${friendly_name} Status"
    id: spa_status
    icon: mdi:hot-tub
    lambda: |-
      String status = "";
      if (id(heater_state)) status += "Heating ";
      if (id(filter_state)) status += "Filtering ";
      if (id(bubble_state)) status += "Bubbles ";
      if (id(jets_state)) status += "Jets ";
      if (status == "") status = "Idle";
      return status;
    update_interval: 10s

  - platform: version
    name: "${friendly_name} ESPHome Version"

  - platform: wifi_info
    ip_address:
      name: "${friendly_name} IP Address"
    ssid:
      name: "${friendly_name} Connected SSID"
    mac_address:
      name: "${friendly_name} MAC Address"

# Button entities for actions
button:
  - platform: restart
    name: "${friendly_name} Restart"

  - platform: template
    name: "${friendly_name} Quick Heat"
    icon: mdi:fire-circle
    on_press:
      - switch.turn_on: heater_switch
      - switch.turn_on: filter_switch
      - number.set:
          id: set_temperature
          value: 40

  - platform: template
    name: "${friendly_name} All Off"
    icon: mdi:power
    on_press:
      - switch.turn_off: heater_switch
      - switch.turn_off: filter_switch
      - switch.turn_off: bubbles_switch
      - switch.turn_off: jets_switch

# Time-based automations
time:
  - platform: homeassistant
    id: homeassistant_time
    on_time:
      # Auto filter twice daily at 8 AM and 8 PM
      - hours: 8,20
        minutes: 0
        seconds: 0
        then:
          - switch.turn_on: filter_switch
          - delay: 2h
          - switch.turn_off: filter_switch

# Interval for periodic tasks
interval:
  # Update temperature readings
  - interval: 30s
    then:
      - logger.log: "Reading spa temperature..."

  # Safety check - turn off heater if temperature too high
  - interval: 1min
    then:
      - if:
          condition:
            lambda: 'return id(current_temperature) > 41;'
          then:
            - switch.turn_off: heater_switch
            - logger.log: "Safety: Temperature too high, turning off heater"
