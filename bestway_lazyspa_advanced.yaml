# Advanced ESPHome Configuration for Bestway Lay-Z-SPA
# With improved protocol handling and MQTT support
# Compatible with both 4-wire and 6-wire models

substitutions:
  device_name: layzspa-advanced
  friendly_name: "Lay-Z-SPA Advanced"
  
  # Model Selection - change to match your model
  # Options: "6wire_2021", "6wire_pre2021", "4wire_2021", "4wire_pre2021"
  model_type: "6wire_2021"
  
  # Pin Configuration for ESP8266 (D1 Mini)
  # Adjust these based on your actual wiring
  cio_data_pin: GPIO5   # D1 - CIO Data (6-wire only)
  cio_clk_pin: GPIO4    # D2 - CIO Clock (6-wire only)  
  cio_cs_pin: GPIO0     # D3 - CIO Chip Select (6-wire only)
  dsp_data_pin: GPIO14  # D5 - DSP Data
  dsp_clk_pin: GPIO12   # D6 - DSP Clock
  dsp_cs_pin: GPIO13    # D7 - DSP Chip Select
  audio_pin: GPIO15     # D8 - Audio/Buzzer (optional)
  
  # Alternative pin configuration for better stability
  # Uncomment if you have issues with the default pins
  # cio_data_pin: GPIO2   # D4
  # cio_clk_pin: GPIO14   # D5
  # cio_cs_pin: GPIO12    # D6
  # dsp_data_pin: GPIO13  # D7
  # dsp_clk_pin: GPIO15   # D8
  # dsp_cs_pin: GPIO16    # D0

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  platform: ESP8266
  board: d1_mini
  compile_process_limit: 1
  
  # Custom includes for advanced protocol handling
  includes:
    - spa_protocol.h
  
  on_boot:
    priority: -100
    then:
      - script.execute: initialize_spa_advanced
      - delay: 3s
      - script.execute: sync_with_pump

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  
  # Static IP configuration (optional)
  # manual_ip:
  #   static_ip: 192.168.1.100
  #   gateway: 192.168.1.1
  #   subnet: 255.255.255.0
  #   dns1: 8.8.8.8
  
  # Enable fallback hotspot
  ap:
    ssid: "${friendly_name} AP"
    password: "layzspa123"
    ap_timeout: 1min

captive_portal:

# Enhanced logging with filters
logger:
  level: DEBUG
  baud_rate: 115200
  logs:
    sensor: INFO
    climate: INFO
    api: WARN
    ota: WARN

# Home Assistant API with encryption
api:
  encryption:
    key: !secret api_encryption_key
  services:
    # Service to send raw commands
    - service: send_raw_command
      variables:
        command: int
      then:
        - lambda: |-
            ESP_LOGD("api", "Received raw command: %d", command);
            id(send_raw_cmd).execute(command);
    
    # Service to display custom text
    - service: display_text
      variables:
        text: string
        duration: int
      then:
        - lambda: |-
            ESP_LOGD("api", "Display text: %s for %d seconds", text.c_str(), duration);
            id(show_display_text).execute(text, duration);

# OTA updates
ota:
  - platform: esphome
    password: !secret ota_password
    on_begin:
      then:
        - logger.log: "OTA update starting..."
    on_end:
      then:
        - logger.log: "OTA update completed!"
    on_error:
      then:
        - logger.log: "OTA update failed!"

# Web server with authentication
web_server:
  port: 80
  auth:
    username: !secret web_username
    password: !secret web_password
  css_url: ""
  js_url: ""

# Global variables with enhanced state management
globals:
  - id: target_temperature_c
    type: float
    restore_value: yes
    initial_value: '38.0'
    
  - id: current_temperature_c
    type: float
    restore_value: no
    initial_value: '0.0'
    
  - id: heater_active
    type: bool
    restore_value: no
    initial_value: 'false'
    
  - id: filter_active
    type: bool
    restore_value: no
    initial_value: 'false'
    
  - id: bubbles_active
    type: bool
    restore_value: no
    initial_value: 'false'
    
  - id: jets_active
    type: bool
    restore_value: no
    initial_value: 'false'
    
  - id: display_locked
    type: bool
    restore_value: yes
    initial_value: 'false'
    
  - id: error_code
    type: int
    restore_value: no
    initial_value: '0'
    
  - id: last_command_time
    type: unsigned long
    restore_value: no
    initial_value: '0'
    
  - id: communication_errors
    type: int
    restore_value: no
    initial_value: '0'

# Custom component for SPA communication
custom_component:
  - lambda: |-
      class BestwaySpaCommunication : public PollingComponent, public Sensor {
       public:
        // Pin definitions
        GPIOPin *cio_data, *cio_clk, *cio_cs;
        GPIOPin *dsp_data, *dsp_clk, *dsp_cs;
        GPIOPin *audio;
        
        // Communication buffers
        uint8_t dsp_buffer[11] = {0};
        uint8_t cio_buffer[11] = {0};
        uint8_t button_code = 0;
        
        BestwaySpaCommunication() : PollingComponent(100) {}
        
        void setup() override {
          // Initialize pins based on model
          std::string model = "${model_type}";
          
          if (model.find("6wire") != std::string::npos) {
            cio_data = new GPIOPin(${cio_data_pin}, OUTPUT);
            cio_clk = new GPIOPin(${cio_clk_pin}, OUTPUT);
            cio_cs = new GPIOPin(${cio_cs_pin}, OUTPUT);
            cio_cs->digital_write(true);
          }
          
          dsp_data = new GPIOPin(${dsp_data_pin}, INPUT);
          dsp_clk = new GPIOPin(${dsp_clk_pin}, INPUT);
          dsp_cs = new GPIOPin(${dsp_cs_pin}, INPUT);
          
          audio = new GPIOPin(${audio_pin}, OUTPUT);
          
          ESP_LOGD("spa", "SPA communication initialized for model: %s", model.c_str());
        }
        
        void update() override {
          // Read DSP data
          if (!dsp_cs->digital_read()) {
            read_dsp_packet();
            process_dsp_data();
          }
          
          // Write CIO data for 6-wire models
          if ("${model_type}".find("6wire") != std::string::npos) {
            write_cio_packet();
          }
          
          // Update global variables
          update_states();
        }
        
        void read_dsp_packet() {
          for (int i = 0; i < 11; i++) {
            uint8_t byte = 0;
            for (int bit = 7; bit >= 0; bit--) {
              while (!dsp_clk->digital_read()) { yield(); }
              byte |= (dsp_data->digital_read() << bit);
              while (dsp_clk->digital_read()) { yield(); }
            }
            dsp_buffer[i] = byte;
          }
        }
        
        void write_cio_packet() {
          cio_cs->digital_write(false);
          delayMicroseconds(50);
          
          for (int i = 0; i < 11; i++) {
            for (int bit = 7; bit >= 0; bit--) {
              cio_clk->digital_write(false);
              cio_data->digital_write((cio_buffer[i] >> bit) & 1);
              delayMicroseconds(10);
              cio_clk->digital_write(true);
              delayMicroseconds(10);
            }
          }
          
          cio_cs->digital_write(true);
        }
        
        void process_dsp_data() {
          // Extract temperature (bytes 1-2)
          float temp = ((dsp_buffer[1] << 8) | dsp_buffer[2]) / 10.0;
          if (temp > 0 && temp < 50) {
            id(current_temperature_c) = temp;
          }
          
          // Extract button press (byte 3)
          button_code = dsp_buffer[3];
          
          // Extract states (byte 4)
          id(heater_active) = (dsp_buffer[4] & 0x01);
          id(filter_active) = (dsp_buffer[4] & 0x02);
          id(bubbles_active) = (dsp_buffer[4] & 0x04);
          
          // Extract error code (byte 5)
          id(error_code) = dsp_buffer[5];
        }
        
        void update_states() {
          // Prepare CIO response
          cio_buffer[0] = 0x55; // Start byte
          cio_buffer[1] = (int)(id(target_temperature_c) * 10) >> 8;
          cio_buffer[2] = (int)(id(target_temperature_c) * 10) & 0xFF;
          cio_buffer[3] = 0; // Status flags
          if (id(heater_active)) cio_buffer[3] |= 0x01;
          if (id(filter_active)) cio_buffer[3] |= 0x02;
          if (id(bubbles_active)) cio_buffer[3] |= 0x04;
          if (id(display_locked)) cio_buffer[3] |= 0x80;
          
          // Calculate checksum
          uint8_t checksum = 0;
          for (int i = 0; i < 10; i++) {
            checksum ^= cio_buffer[i];
          }
          cio_buffer[10] = checksum;
        }
        
        void send_button_press(uint8_t button) {
          cio_buffer[4] = button;
          write_cio_packet();
          delay(100);
          cio_buffer[4] = 0;
          write_cio_packet();
        }
      };
      
      auto spa_comm = new BestwaySpaCommunication();
      return {spa_comm};
    id: spa_communication

# Enhanced Scripts
script:
  - id: initialize_spa_advanced
    then:
      - logger.log: "Starting advanced SPA initialization..."
      - lambda: |-
          // Reset communication counters
          id(communication_errors) = 0;
          id(last_command_time) = millis();
      - delay: 2s
      - if:
          condition:
            lambda: 'return "${model_type}".find("6wire") != std::string::npos;'
          then:
            - logger.log: "Initializing 6-wire model communication..."
          else:
            - logger.log: "Initializing 4-wire model communication..."
      
  - id: sync_with_pump
    then:
      - logger.log: "Synchronizing with pump controller..."
      - delay: 1s
      - lambda: |-
          // Send sync sequence
          id(spa_communication).send_button_press(0xFF);
      
  - id: send_raw_cmd
    parameters:
      cmd: int
    then:
      - lambda: |-
          ESP_LOGD("script", "Sending raw command: 0x%02X", cmd);
          id(spa_communication).send_button_press(cmd);
          id(last_command_time) = millis();
      
  - id: show_display_text
    parameters:
      text: string
      duration: int
    then:
      - logger.log:
          format: "Displaying text: %s for %d seconds"
          args: ['text.c_str()', 'duration']

  - id: emergency_stop
    then:
      - logger.log: "EMERGENCY STOP - Turning off all systems"
      - switch.turn_off: heater_control
      - switch.turn_off: filter_control
      - switch.turn_off: bubbles_control
      - switch.turn_off: jets_control
      - delay: 1s
      - lambda: |-
          // Send emergency stop command
          id(spa_communication).send_button_press(0x00);

# Enhanced Sensors
sensor:
  # Current water temperature with filtering
  - platform: template
    name: "${friendly_name} Water Temperature"
    id: water_temp
    device_class: temperature
    state_class: measurement
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    icon: mdi:thermometer-water
    lambda: |-
      return id(current_temperature_c);
    update_interval: 5s
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 2
      - or:
        - throttle: 30s
        - delta: 0.5
    
  # Target temperature
  - platform: template
    name: "${friendly_name} Target Temperature"
    id: target_temp
    device_class: temperature
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    icon: mdi:thermometer
    lambda: |-
      return id(target_temperature_c);
    update_interval: 10s
    
  # Power consumption estimation (rough)
  - platform: template
    name: "${friendly_name} Estimated Power"
    id: power_estimate
    device_class: power
    state_class: measurement
    unit_of_measurement: "W"
    accuracy_decimals: 0
    icon: mdi:lightning-bolt
    lambda: |-
      float power = 0;
      if (id(heater_active)) power += 2800;  // Heater ~2.8kW
      if (id(filter_active)) power += 60;    // Filter pump ~60W
      if (id(bubbles_active)) power += 800;   // Air pump ~800W
      if (id(jets_active)) power += 600;     // Jets pump ~600W
      return power;
    update_interval: 10s
    
  # Communication quality
  - platform: template
    name: "${friendly_name} Comm Quality"
    id: comm_quality
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: mdi:signal
    lambda: |-
      float quality = 100.0 - (id(communication_errors) * 2);
      if (quality < 0) quality = 0;
      return quality;
    update_interval: 30s
    
  # Uptime sensor
  - platform: uptime
    name: "${friendly_name} Uptime"
    id: uptime_sensor
    update_interval: 60s
    
  # WiFi Signal
  - platform: wifi_signal
    name: "${friendly_name} WiFi Signal"
    update_interval: 60s
    
  # Error code sensor
  - platform: template
    name: "${friendly_name} Error Code"
    id: error_sensor
    accuracy_decimals: 0
    icon: mdi:alert-circle
    lambda: |-
      return id(error_code);
    update_interval: 10s

# Binary Sensors
binary_sensor:
  # Heater status
  - platform: template
    name: "${friendly_name} Heater Status"
    id: heater_status
    device_class: heat
    lambda: |-
      return id(heater_active);
      
  # Filter status
  - platform: template
    name: "${friendly_name} Filter Status"
    id: filter_status
    device_class: running
    lambda: |-
      return id(filter_active);
      
  # Bubbles status
  - platform: template
    name: "${friendly_name} Bubbles Status"
    id: bubbles_status
    lambda: |-
      return id(bubbles_active);
      
  # Jets status
  - platform: template
    name: "${friendly_name} Jets Status"
    id: jets_status
    lambda: |-
      return id(jets_active);
      
  # Display lock status
  - platform: template
    name: "${friendly_name} Display Lock"
    id: lock_status
    device_class: lock
    lambda: |-
      return id(display_locked);
      
  # Error state
  - platform: template
    name: "${friendly_name} Error State"
    id: error_state
    device_class: problem
    lambda: |-
      return id(error_code) > 0;

# Enhanced Switches with safety features
switch:
  # Heater control with temperature safety
  - platform: template
    name: "${friendly_name} Heater"
    id: heater_control
    icon: mdi:fire
    lambda: |-
      return id(heater_active);
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(current_temperature_c) < 41;'
          then:
            - lambda: |-
                id(spa_communication).send_button_press(0x10); // Heater button code
            - globals.set:
                id: heater_active
                value: 'true'
          else:
            - logger.log: "Temperature too high, heater not activated"
    turn_off_action:
      - lambda: |-
          id(spa_communication).send_button_press(0x10); // Same button toggles
      - globals.set:
          id: heater_active
          value: 'false'
    restore_mode: RESTORE_DEFAULT_OFF
          
  # Filter control
  - platform: template
    name: "${friendly_name} Filter"
    id: filter_control
    icon: mdi:air-filter
    lambda: |-
      return id(filter_active);
    turn_on_action:
      - lambda: |-
          id(spa_communication).send_button_press(0x20); // Filter button code
      - globals.set:
          id: filter_active
          value: 'true'
    turn_off_action:
      - lambda: |-
          id(spa_communication).send_button_press(0x20);
      - globals.set:
          id: filter_active
          value: 'false'
    restore_mode: RESTORE_DEFAULT_OFF
          
  # Bubbles control with timer
  - platform: template
    name: "${friendly_name} Bubbles"
    id: bubbles_control
    icon: mdi:chart-bubble
    lambda: |-
      return id(bubbles_active);
    turn_on_action:
      - lambda: |-
          id(spa_communication).send_button_press(0x40); // Bubbles button code
      - globals.set:
          id: bubbles_active
          value: 'true'
      - delay: 30min  # Auto-off after 30 minutes
      - switch.turn_off: bubbles_control
    turn_off_action:
      - lambda: |-
          id(spa_communication).send_button_press(0x40);
      - globals.set:
          id: bubbles_active
          value: 'false'
    restore_mode: RESTORE_DEFAULT_OFF
          
  # Jets control (if available)
  - platform: template
    name: "${friendly_name} Jets"
    id: jets_control
    icon: mdi:water
    lambda: |-
      return id(jets_active);
    turn_on_action:
      - lambda: |-
          id(spa_communication).send_button_press(0x80); // Jets button code
      - globals.set:
          id: jets_active
          value: 'true'
      - delay: 30min  # Auto-off after 30 minutes
      - switch.turn_off: jets_control
    turn_off_action:
      - lambda: |-
          id(spa_communication).send_button_press(0x80);
      - globals.set:
          id: jets_active
          value: 'false'
    restore_mode: RESTORE_DEFAULT_OFF
          
  # Display lock
  - platform: template
    name: "${friendly_name} Lock"
    id: lock_control
    icon: mdi:lock
    lambda: |-
      return id(display_locked);
    turn_on_action:
      - lambda: |-
          id(spa_communication).send_button_press(0x08); // Lock button code
      - globals.set:
          id: display_locked
          value: 'true'
    turn_off_action:
      - lambda: |-
          id(spa_communication).send_button_press(0x08);
      - globals.set:
          id: display_locked
          value: 'false'
    restore_mode: RESTORE_DEFAULT_OFF

# Advanced Climate Control
climate:
  - platform: thermostat
    name: "${friendly_name}"
    id: spa_climate
    sensor: water_temp
    min_heating_off_time: 300s
    min_heating_run_time: 300s
    min_idle_time: 60s
    
    visual:
      min_temperature: 20
      max_temperature: 40
      temperature_step: 0.5
      
    heat_action:
      - switch.turn_on: heater_control
      - switch.turn_on: filter_control
      
    idle_action:
      - switch.turn_off: heater_control
      
    target_temperature_change_action:
      - lambda: |-
          float new_temp = id(spa_climate).target_temperature;
          id(target_temperature_c) = new_temp;
          ESP_LOGD("climate", "Target temperature changed to: %.1f", new_temp);
          
          // Send temperature change commands
          if (new_temp > id(current_temperature_c)) {
            id(spa_communication).send_button_press(0x01); // Temp up
          } else {
            id(spa_communication).send_button_press(0x02); // Temp down
          }
    
    default_preset: Home
    on_boot_restore_from: default_preset
    
    preset:
      - name: Home
        default_target_temperature_low: 38°C
        mode: heat
      - name: Eco
        default_target_temperature_low: 35°C
        mode: heat
      - name: Boost
        default_target_temperature_low: 40°C
        mode: heat

# Number inputs
number:
  # Manual temperature setting
  - platform: template
    name: "${friendly_name} Temperature Setting"
    id: temp_setting
    min_value: 20
    max_value: 40
    step: 0.5
    unit_of_measurement: "°C"
    icon: mdi:thermometer
    mode: slider
    lambda: |-
      return id(target_temperature_c);
    set_action:
      - globals.set:
          id: target_temperature_c
          value: !lambda 'return x;'
      - climate.control:
          id: spa_climate
          target_temperature: !lambda 'return x;'
          
  # Filter duration setting
  - platform: template
    name: "${friendly_name} Filter Duration"
    id: filter_duration
    min_value: 1
    max_value: 12
    step: 1
    unit_of_measurement: "hours"
    icon: mdi:timer
    mode: box
    initial_value: 2
    restore_value: true

# Select options
select:
  # Operating mode
  - platform: template
    name: "${friendly_name} Mode"
    id: spa_mode
    icon: mdi:hot-tub
    options:
      - "Off"
      - "Filter Only"
      - "Heat"
      - "Heat + Filter"
      - "Maintenance"
    initial_option: "Off"
    restore_value: true
    set_action:
      - lambda: |-
          std::string mode = x;
          if (mode == "Off") {
            id(heater_control).turn_off();
            id(filter_control).turn_off();
            id(bubbles_control).turn_off();
          } else if (mode == "Filter Only") {
            id(heater_control).turn_off();
            id(filter_control).turn_on();
          } else if (mode == "Heat") {
            id(heater_control).turn_on();
            id(filter_control).turn_off();
          } else if (mode == "Heat + Filter") {
            id(heater_control).turn_on();
            id(filter_control).turn_on();
          } else if (mode == "Maintenance") {
            id(filter_control).turn_on();
            id(bubbles_control).turn_on();
          }

# Text Sensors
text_sensor:
  # System status
  - platform: template
    name: "${friendly_name} System Status"
    id: system_status
    icon: mdi:information
    lambda: |-
      if (id(error_code) > 0) {
        switch(id(error_code)) {
          case 1: return {"E01: Flow Error"};
          case 2: return {"E02: Water Temp Sensor"};
          case 3: return {"E03: Overheat Protection"};
          case 4: return {"E04: Freeze Protection"};
          case 5: return {"E05: Dry Heat Protection"};
          case 6: return {"E06: Communication Error"};
          default: return {"Unknown Error: " + std::to_string(id(error_code))};
        }
      }
      
      std::string status = "Ready";
      if (id(heater_active) && id(filter_active)) {
        status = "Heating & Filtering";
      } else if (id(heater_active)) {
        status = "Heating";
      } else if (id(filter_active)) {
        status = "Filtering";
      } else if (id(bubbles_active)) {
        status = "Bubbles Active";
      }
      return {status};
    update_interval: 5s
    
  # Model information
  - platform: template
    name: "${friendly_name} Model"
    id: model_info
    icon: mdi:information-outline
    lambda: |-
      return {"${model_type}"};
    update_interval: never
    
  # Last command
  - platform: template
    name: "${friendly_name} Last Command"
    id: last_command
    icon: mdi:console
    lambda: |-
      unsigned long elapsed = (millis() - id(last_command_time)) / 1000;
      if (elapsed < 60) {
        return {std::to_string(elapsed) + " seconds ago"};
      } else if (elapsed < 3600) {
        return {std::to_string(elapsed / 60) + " minutes ago"};
      } else {
        return {std::to_string(elapsed / 3600) + " hours ago"};
      }
    update_interval: 30s
    
  # WiFi Info
  - platform: wifi_info
    ip_address:
      name: "${friendly_name} IP"
      icon: mdi:ip-network
    ssid:
      name: "${friendly_name} SSID"
      icon: mdi:wifi
    mac_address:
      name: "${friendly_name} MAC"
      icon: mdi:lan

# Button controls
button:
  # System restart
  - platform: restart
    name: "${friendly_name} Restart"
    icon: mdi:restart
    
  # Emergency stop
  - platform: template
    name: "${friendly_name} Emergency Stop"
    icon: mdi:alert-octagon
    on_press:
      - script.execute: emergency_stop
      
  # Quick heat mode
  - platform: template
    name: "${friendly_name} Quick Heat"
    icon: mdi:rocket-launch
    on_press:
      - select.set:
          id: spa_mode
          option: "Heat + Filter"
      - climate.control:
          id: spa_climate
          target_temperature: 40
          mode: heat
          
  # Maintenance mode
  - platform: template
    name: "${friendly_name} Maintenance"
    icon: mdi:wrench
    on_press:
      - select.set:
          id: spa_mode
          option: "Maintenance"
      - delay: 10min
      - select.set:
          id: spa_mode
          option: "Off"
          
  # Sync button
  - platform: template
    name: "${friendly_name} Sync"
    icon: mdi:sync
    on_press:
      - script.execute: sync_with_pump

# Time-based automation
time:
  - platform: homeassistant
    id: homeassistant_time
    
    # Morning filter cycle
    on_time:
      - hours: 8
        minutes: 0
        seconds: 0
        then:
          - switch.turn_on: filter_control
          - delay: !lambda 'return id(filter_duration).state * 3600;'
          - switch.turn_off: filter_control
          
    # Evening filter cycle
    on_time:
      - hours: 20
        minutes: 0
        seconds: 0
        then:
          - switch.turn_on: filter_control
          - delay: !lambda 'return id(filter_duration).state * 3600;'
          - switch.turn_off: filter_control
          
    # Weekly maintenance
    on_time:
      - hours: 10
        minutes: 0
        seconds: 0
        days_of_week: SUN
        then:
          - button.press: spa_maintenance

# Interval-based monitoring
interval:
  # Monitor communication health
  - interval: 30s
    then:
      - if:
          condition:
            lambda: 'return id(communication_errors) > 10;'
          then:
            - logger.log: "High communication errors detected"
            - lambda: |-
                id(communication_errors) = 0;  // Reset counter
                
  # Temperature safety check
  - interval: 1min
    then:
      - if:
          condition:
            lambda: 'return id(current_temperature_c) > 41;'
          then:
            - logger.log: "Temperature too high! Shutting down heater"
            - switch.turn_off: heater_control
            - homeassistant.service:
                service: notify.notify
                data:
                  message: "Spa temperature too high! Heater disabled."
                  
  # Auto-save energy mode at night
  - interval: 1h
    then:
      - if:
          condition:
            - lambda: |-
                auto time = id(homeassistant_time).now();
                return time.hour >= 23 || time.hour < 6;
          then:
            - if:
                condition:
                  lambda: 'return id(target_temperature_c) > 35;'
                then:
                  - climate.control:
                      id: spa_climate
                      target_temperature: 35
