# Diagnostic ESPHome Configuration for Bestway Lay-Z-SPA
# ESP32 VERSION
# This is a simplified version to test if your hardware connections work
# Use this FIRST before the advanced version

substitutions:
  device_name: spa-diagnostic
  friendly_name: "Spa Diagnostic"

  # ============================================================
  # PIN CONFIGURATION for ESP32 (6-WIRE 2021 MODEL)
  # ============================================================
  # ESP32 has different GPIO numbers than ESP8266!
  #
  # WIRING from SPA PUMP to ESP32 (via level shifter):
  #
  # Spa Pin -> Level Shifter -> ESP32 Pin
  # ------------------------------------------------
  # Pin 1 (5V)      -> HV        -> 5V/VIN
  # Pin 2 (GND)     -> GND       -> GND
  # Pin 3 (CIO Data) -> HV1<->LV1 -> GPIO21 ← cio_data_pin
  # Pin 4 (CIO Clk)  -> HV2<->LV2 -> GPIO22 ← cio_clk_pin
  # Pin 5 (CIO CS)   -> HV3<->LV3 -> GPIO23 ← cio_cs_pin
  # Pin 6 (DSP Data) -> HV4<->LV4 -> GPIO19 ← dsp_data_pin
  # Pin 7 (DSP Clk)  -> HV5<->LV5 -> GPIO18 ← dsp_clk_pin
  # Pin 8 (DSP CS)   -> HV6<->LV6 -> GPIO5  ← dsp_cs_pin
  #
  # NOTE: These pins avoid strapping pins and boot-critical pins
  # ============================================================

  # ESP32 Pin Configuration (6-wire model)
  cio_data_pin: GPIO21  # CIO Data (6-wire only)
  cio_clk_pin: GPIO22   # CIO Clock (6-wire only)
  cio_cs_pin: GPIO23    # CIO Chip Select (6-wire only)
  dsp_data_pin: GPIO19  # DSP Data (all models)
  dsp_clk_pin: GPIO18   # DSP Clock (all models)
  dsp_cs_pin: GPIO5     # DSP Chip Select (all models)

  # ============================================================
  # ALTERNATIVE PINS (if you have conflicts)
  # ============================================================
  # These are other safe pins you can use on ESP32:
  # GPIO16, GPIO17, GPIO25, GPIO26, GPIO27, GPIO32, GPIO33
  #
  # AVOID these pins on ESP32:
  # - GPIO0 (boot button)
  # - GPIO2 (on-board LED, strapping pin)
  # - GPIO12 (strapping pin - boot fails if HIGH)
  # - GPIO15 (strapping pin)
  # - GPIO6-11 (connected to flash - DO NOT USE)
  # ============================================================

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}

  # ESP32 configuration (different from ESP8266!)
  platformio_options:
    board_build.flash_mode: dio

esp32:
  board: esp32dev  # Use esp32dev for generic ESP32 boards
  framework:
    type: arduino

# WiFi configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Fallback hotspot
  ap:
    ssid: "${friendly_name} Fallback"
    password: "diagnostic123"

captive_portal:

# Enable logging
logger:
  level: DEBUG
  baud_rate: 115200

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

# Enable OTA updates
ota:
  - platform: esphome
    password: !secret ota_password

# Web server for standalone access
web_server:
  port: 80

# Global variables for testing
globals:
  - id: dsp_packet_count
    type: int
    restore_value: no
    initial_value: '0'

  - id: last_dsp_data
    type: uint8_t[11]
    restore_value: no

# Simple binary sensors to monitor pin states
binary_sensor:
  # Monitor DSP chip select - should toggle when spa sends data
  - platform: gpio
    name: "${friendly_name} DSP CS Active"
    id: dsp_cs_active
    pin:
      number: ${dsp_cs_pin}
      mode: INPUT
      inverted: true  # CS is active low
    on_press:
      then:
        - logger.log: "DSP CS activated - pump is sending data"
    on_release:
      then:
        - logger.log: "DSP CS deactivated"

  # Monitor DSP clock - should be pulsing during transmission
  - platform: gpio
    name: "${friendly_name} DSP Clock"
    id: dsp_clock
    pin:
      number: ${dsp_clk_pin}
      mode: INPUT
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms

  # Monitor DSP data line
  - platform: gpio
    name: "${friendly_name} DSP Data"
    id: dsp_data_pin
    pin:
      number: ${dsp_data_pin}
      mode: INPUT
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms

# Sensors to track communication
sensor:
  # Count DSP packets received
  - platform: template
    name: "${friendly_name} DSP Packet Count"
    id: packet_counter
    accuracy_decimals: 0
    lambda: |-
      return id(dsp_packet_count);
    update_interval: 5s

  # WiFi signal strength
  - platform: wifi_signal
    name: "${friendly_name} WiFi Signal"
    update_interval: 60s

  # Uptime
  - platform: uptime
    name: "${friendly_name} Uptime"
    update_interval: 60s

# Text sensors for diagnostic messages and info
text_sensor:
  # Connection status
  - platform: template
    name: "${friendly_name} Status"
    id: diagnostic_status
    icon: mdi:information
    lambda: |-
      if (id(dsp_packet_count) > 0) {
        return {"Connected - Packets: " + to_string(id(dsp_packet_count))};
      } else {
        return {"Waiting for spa data..."};
      }
    update_interval: 5s

  # Instructions displayed in web interface
  - platform: template
    name: "${friendly_name} Instructions"
    icon: mdi:help-circle
    lambda: |-
      return {
        "ESP32 DIAGNOSTIC MODE: "
        "1) Flash this config to ESP32. "
        "2) Power on spa pump. "
        "3) Watch DSP CS Active sensor - should toggle. "
        "4) Check packet count - should increase. "
        "5) If packet count stays 0: wiring issue. "
        "6) If packet count increases: hardware OK!"
      };
    update_interval: never

  # IP address
  - platform: wifi_info
    ip_address:
      name: "${friendly_name} IP Address"

# Interval for checking communication
interval:
  # Check if we're receiving data every 30 seconds
  - interval: 30s
    then:
      - lambda: |-
          static int last_count = 0;
          int current_count = id(dsp_packet_count);

          if (current_count > last_count) {
            ESP_LOGI("diagnostic", "Communication OK - received %d packets in last 30s",
                     current_count - last_count);
            last_count = current_count;
          } else if (last_count > 0) {
            ESP_LOGW("diagnostic", "WARNING: No packets received in last 30 seconds!");
            ESP_LOGW("diagnostic", "Check:");
            ESP_LOGW("diagnostic", "  1. Is the spa pump powered on?");
            ESP_LOGW("diagnostic", "  2. Are the wires connected correctly?");
            ESP_LOGW("diagnostic", "  3. Is the level shifter working (6-wire models)?");
          } else {
            ESP_LOGW("diagnostic", "Waiting for spa to send data...");
            ESP_LOGW("diagnostic", "Make sure spa pump is powered on and connected.");
          }

  # Monitor pin states every 10 seconds
  - interval: 10s
    then:
      - lambda: |-
          bool cs = id(dsp_cs_active).state;
          bool clk = id(dsp_clock).state;
          bool data = id(dsp_data_pin).state;

          ESP_LOGD("pins", "Pin states - CS:%d CLK:%d DATA:%d", cs, clk, data);

          // Check if pins are stuck
          static int stuck_count = 0;
          static bool last_clk = false;

          if (clk == last_clk) {
            stuck_count++;
            if (stuck_count > 6) {  // 60 seconds of no change
              ESP_LOGW("pins", "Clock pin appears stuck! Check wiring.");
            }
          } else {
            stuck_count = 0;
          }
          last_clk = clk;

# Button controls
button:
  - platform: restart
    name: "${friendly_name} Restart"

  - platform: template
    name: "${friendly_name} Reset Packet Counter"
    icon: mdi:counter
    on_press:
      - lambda: |-
          id(dsp_packet_count) = 0;
          ESP_LOGI("diagnostic", "Packet counter reset");
